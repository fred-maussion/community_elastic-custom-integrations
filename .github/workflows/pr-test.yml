name: PR Test Check

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, ready_for_review]

permissions:
  contents: read
  checks: write
  packages: read
  pull-requests: write

jobs:
  pr-checks:
    name: Run PR Checks
    runs-on: ubuntu-latest
   
    steps:
      - name: Checkout PR branch and main
        uses: actions/checkout@v3
        with:
            fetch-depth: 0
            ref: ${{ github.event.pull_request.head.ref }}

      - name: Fetch origin/main
        run: |
            git fetch origin main

      - name: Determine Changed Packages
        id: changed
        run: |
            echo "Detecting changed packages..."
            PACKAGES=$(ls -d */ | cut -f1 -d'/')
            echo "PACKAGES : $PACKAGES"

            for pkg in $PACKAGES; do
            if git diff --name-only origin/main...HEAD | grep -q "^${pkg}/"; then
                echo "Detected changes in: $pkg"
                CHANGED_APPS="$CHANGED_APPS $pkg"
            fi
            done

            if [ -z "$CHANGED_APPS" ]; then
            echo "No changed packages detected."
            echo "changed_apps=" >> $GITHUB_ENV
            exit 0
            fi

            echo "changed_apps=$CHANGED_APPS" >> $GITHUB_ENV
            echo "Changed packages: $CHANGED_APPS"

      - name: Skip if no changed apps
        if: env.changed_apps == ''
        run: echo "No changed apps found. Skipping tests."

      - name: Run Fast Tests on Changed Packages
        if: env.changed_apps != ''
        run: |
          IMAGE_PATH=ghcr.io/${{ github.repository_owner }}/custom-integrations/elastic-package
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker pull $IMAGE_PATH:latest

          for app in ${{ env.changed_apps }}; do
            echo "Running fast tests for $app"
            docker run --rm -v $PWD:/workspace -w /workspace $IMAGE_PATH:latest sh -c "
              cd $app;
              echo 'Running lint...'
              elastic-package lint;
              echo 'Running static tests...'
              elastic-package test static --report-format xUnit --report-output file;
            "
          done

      - name: Publish Fast Test Results
        # Use if: always() so this step runs even if the previous step fails
        if: always() && env.changed_apps != ''
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          check_name: Fast Tests
          files: 'build/test-results/*-static-*.xml'

      - name: Run Costly Tests on Changed Packages
        if: env.changed_apps != '' && github.event.pull_request.draft == false
        env:
          # Make secrets available to the docker run command
          EC_API_KEY: ${{ secrets.EC_API_KEY }}
          ELASTIC_PACKAGE_SERVERLESS_PIPELINE_TEST_DISABLE_COMPARE_RESULTS: "true"
        run: |
          echo "PR IS NOT DRAFT: Running costly E2E tests..."
          IMAGE_PATH=ghcr.io/${{ github.repository_owner }}/custom-integrations/elastic-package
          
          for app in ${{ env.changed_apps }}; do
            echo "--- Running Costly Tests for $app ---"
            
            # This script will run INSIDE the container
            # We create it dynamically to handle logging and cleanup
            # All content from here to RUN_SCRIPT MUST have no indentation
            cat << 'RUN_SCRIPT' > "run_script_${app}.sh"
          #!/bin/sh
          # Exit immediately if a command exits with a non-zero status
          set -e 

          echo "--- [$0] Inside container for $1 ---"

          # --- Install Docker Client ---
          echo "Inside container: Installing docker client (Alpine base)..."
          # Add docker-cli and the compose plugin (docker-cli-compose)
          apk add --no-cache docker-cli docker-cli-compose
          echo "Docker client installed."
          # --- End Docker Client Install ---

          # --- Create Serverless Profile ---
          echo "Inside container: Creating serverless profile..."
          elastic-package profiles create serverless
          elastic-package profiles use serverless

          echo "Inside container: Writing profile config..."
          # This path is /root/.elastic-package inside the container
          mkdir -p /root/.elastic-package/profiles/serverless
          cat <<EOF > /root/.elastic-package/profiles/serverless/config.yml
          stack.elastic_cloud.host: https://cloud.elastic.co
          stack.serverless.type: security
          stack.serverless.region: aws-us-east-1
          EOF
          echo "Serverless profile 'serverless' configured."
          # --- End Profile Creation ---

          # cd into the app directory
          cd $1

          # Create a log file for the stack up command
          STACK_UP_LOG="stack-up.log"

          # Run stack up, redirecting all output to the log file
          # Use 'set +e' to handle the exit code manually
          set +e
          elastic-package stack up -d --provider serverless -v &> $STACK_UP_LOG
          STACK_UP_STATUS=$?
          set -e

          USERNAME=$(grep 'Username: ' $STACK_UP_LOG | awk '{print $2}')
          PASSWORD=$(grep 'Password: ' $STACK_UP_LOG | awk '{print $2}')

          if [ -n "$USERNAME" ]; then
              echo "::add-mask::$USERNAME"
          fi
          if [ -n "$PASSWORD" ]; then
              echo "::add-mask::$PASSWORD"
          fi

          echo "--- Stack Up Logs ---"
          cat $STACK_UP_LOG
          echo "---------------------"

          # Check if stack up failed
          if [ $STACK_UP_STATUS -ne 0 ]; then
              echo "elastic-package stack up failed"
              # Attempt cleanup just in case
              elastic-package stack down || echo "Stack down failed, proceeding..."
              exit $STACK_UP_STATUS
          fi

          # Run tests
          # Use 'set +e' again to capture status and ensure stack down
          set +e
          echo "--- Running Tests ---"

          # Determine integration type from manifest.yml
          INTEGRATION_TYPE=$(grep -E '^type:' manifest.yml | awk '{print $2}' | tr -d '"')
          echo "Detected integration type: $INTEGRATION_TYPE"

          # Added --report-output file to all test commands
          if [ "$INTEGRATION_TYPE" = "integration" ] || [ "$INTEGACTION_TYPE" = "input" ]; then
              echo "Running full test suite for '$INTEGRATION_TYPE' type..."
              elastic-package test asset --report-format xUnit --report-output file && \
              elastic-package test pipeline --report-format xUnit --report-output file && \
              elastic-package test policy --report-format xUnit --report-output file && \
              elastic-package test --report-format xUnit --report-output file
          elif [ "$INTEGRATION_TYPE" = "content" ]; then
              echo "Running partial test suite for 'content' type..."
              elastic-package test asset --report-format xUnit --report-output file && \
              elastic-package test pipeline --report-format xUnit --report-output file
          else
              echo "Unknown or unset integration type '$INTEGRATION_TYPE'. Running full test suite as default..."
              elastic-package test asset --report-format xUnit --report-output file && \
              elastic-package test pipeline --report-format xUnit --report-output file && \
              elastic-package test policy --report-format xUnit --report-output file && \
              elastic-package test --report-format xUnit --report-output file
          fi

          TEST_STATUS=$? # Capture test status
          set -e

          # Always run stack down
          echo "--- Tearing Down Stack ---"
          elastic-package stack down

          # Exit with test status if tests failed
          if [ $TEST_STATUS -ne 0 ]; then
              echo "Tests failed"
              exit $TEST_STATUS
          fi

          echo "--- Successfully completed tests ---"
          exit 0
          RUN_SCRIPT
            
            # Make the script executable
            chmod +x "run_script_${app}.sh"
            
            # Execute the script inside the docker container
            docker run --rm \
              -e EC_API_KEY \
              -e ELASTIC_PACKAGE_SERVERLESS_PIPELINE_TEST_DISABLE_COMPARE_RESULTS \
              -v $PWD:/workspace \
              -v /var/run/docker.sock:/var/run/docker.sock \
              -w /workspace \
              $IMAGE_PATH:latest \
              sh "/workspace/run_script_${app}.sh" $app
            
            # Clean up the script
            rm "run_script_${app}.sh"
          done

      - name: Publish Costly Test Results
        if: env.changed_apps != '' && github.event.pull_request.draft == false
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          check_name: Costly Tests
          files: |
            build/test-results/*-asset-*.xml
            build/test-results/*-pipeline-*.xml
            build/test-results/*-policy-*.xml
            build/test-results/*-test-*.xml

